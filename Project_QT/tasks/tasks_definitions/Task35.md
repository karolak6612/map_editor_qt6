**Task35: Begin Implementing `SpriteManager` (Loaders)**
*  Implement .spr/.dat loading, converting any image processing related to RLE compression from original wxWidgets Item/Graphics to Qt data structures, making the current Sprite load via a setPixel like call rather than QDC using QPainter functions in createImage, supporting only 32x32 resolution (as imageSpace has no additional information so 32x32 is implicit, any scaling should be separate) loading with correct image/sprites format to create `ImageSpace` for usage later. The `wx` RME readTibiaSprHeader assumes the DAT header version can be used for what SpriteLoader class to instantiate when reading headers and which version they imply, store the sprHeader or related version from this loader but no need to parse item data if SPR loaders primary job was sprite-frame indices into GameSprites from items loaded into ItemTypes; also make it compatible to later read animation parameters into new animators structure if needed from GameSprite data loading. Implement readTibiaDatHeader() parsing all data from `instream`, this now will only gather general header attributes, for instance only reading how many "outfits", or "itemtypes" for `ITEMGROUP_TYPE_*` will be there (from ItemManager/ItemType) in Items_otb header reading but defer actual ItemType loading itself. Any actual properties loading should be from dedicated calls from ItemManager since item count seems to correspond to sprite IDs found or is max ID + 1 when parsed using getItemSpriteMaxID method, which seems its used in main to limit loading item sprite. For item loading implement those now, these seem to have properties defined by items.otb/game.items files for `ItemData` structure (which itself then gets set using Items data loaded in ItemDatabase); make sure correct read logic or helper (for flags, as ItemProperty enum should already define the ones present in that header/source code files) also exists. Sprite and SpriteInfo types themselves now should be using or be adapted into EditorSprite or GameSprite which ideally keep a separate cache or storage like in wxwidgets SpriteDatabase to optimize lookup, as sprites will likely get re-used a lot across all Tile items and palettes, along with GameSprites handling for later full mount-drawing logic via getCreatureSprite to find based on Client's version's current id logic in that context which seems very convoluted as `Wx::loadCreatureTypes` also loads those GameSprite references for their lookTypes in sprites with explicit load if item was not loaded earlier. If they need special initialization ensure `GameSprite::SetupVars` is migrated but do not bother migrating Tile flags, that's probably done via other functions; use current floor data/visibility from Map. `UpdateFlags` for item status (e.g. highlighted in selection mode which should eventually need similar selection tracking using bounding boxes and Item lists like in Map but without actual implementation here) using map.cpp tile flags as a rough guide when those need integrating from other items state; those for internal flags setting related to house/waypoint/other tile and item changes using Item->addProperty if they also need it set that way to query state, even if they're a simple item on Tile or some specific items are categorized (like items in doors), though those should still set isDoor using a simple getter/setter directly from Item later even if some specialized items do NOT belong to the tile lists if that logic must be copied but no complex structure if that changes during actual creation and insertion with DoorBrush for example to ensure Tile items keep basic interface while allowing complex ones as members.
