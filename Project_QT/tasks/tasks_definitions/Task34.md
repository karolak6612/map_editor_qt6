**Task34: Brush interaction structure and helpers (Full Mouse Event to Tile/Action Logic, Including `MapCanvas` State Machines)**
- Task: **Create new classes and/or structures (or significantly refactor existing ones) within `project_qt` to comprehensively handle user interactions for brushes. This includes translating `MapCanvas` mouse events into brush actions and managing interaction states, based on the detailed logic in `wxwidgets::canvas.cpp` and any associated brush interaction helper classes.**
    - **Analyze Existing Brush Interaction Code (`Project_QT/src`):** Adapt or replace any rudimentary brush interaction logic.
    - **Event Propagation & Processing:**
        -   Mouse events (`QMouseEvent` for clicks, drags, moves) from `MapCanvas` (the Qt `MapView`) must be processed to determine if a brush action should occur.
        -   This includes logic for: main `MapCanvas` drawing interactions, right-click context menu invocations if brushes have context actions (`Task34.md` should specify which).
    - **Tile/Area Identification:**
        -   Convert mouse coordinates precisely to target tile coordinates (X,Y,Z), considering active layer, `MapView` zoom/pan, and brush properties (size, shape).
        -   Implement logic for identifying single tiles or rectangular/shaped areas based on the current brush type and mouse drag operations.
    - **Porting `canvas.cpp` State Machines:** If `wxwidgets::canvas.cpp` (or similar) used explicit state machines to manage different phases of mouse interaction (e.g., `STATE_IDLE`, `STATE_DRAWING_RECT`, `STATE_DRAGGING_SELECTION`), port this state management logic. The `MapView` or a dedicated `BrushInteractionController` will manage this state.
    - **Signaling `Map` and `Selection` for Updates:** Implement the system by which brush actions signal the `Map` data model and the `Selection` object that changes have occurred or are about to occur. This includes placeholder calls that will eventually trigger:
        -   `Tile` item additions/removals (e.g., `map->executeCommand(new AddItemCommand(tile, itemToDraw))`).
        -   Modification of `Tile` properties.
        -   `updateTiles(QRect area)` or `updateTile(QPoint3D pos)` notifications for visual refresh.
    - **`MapView` Mouse Event Handling:** The `MapView`'s `mousePressEvent`, `mouseMoveEvent`, `mouseReleaseEvent` will be central to this. They will:
        -   Update the internal state machine (if ported).
        -   Identify target tiles.
        -   If a brush is active, call methods on the active `Brush` (e.g., `brush->startDraw(map, targetTile)`, `brush->drawTo(map, targetTile)`, `brush->endDraw(map, targetArea)`).
        -   Manage visual feedback like updating selection boxes (`wxWidgets::SelectionBoxUpdate` logic) if drawing selection areas, which should now interact with the `QGraphicsItem` for selection (Task 58).
    - **Separation of Concerns:** Actual `Tile`/`Map` data manipulation (the "effect" of the brush) will typically be encapsulated in `Command` objects (e.g., `AddItemCommand`, `RemoveItemCommand`, specific brush action commands) and executed by a command processor (for undo/redo). This task focuses on the *event-to-action-intent* part. `Brush` methods might return these commands.
    - **Specific Brush Interaction Logic (`drawTile`, `addTileItem`):** Port logic for how basic `drawTile` operations or generic `addTileItem` based on a brush selection signals changes to the map and selection system to ensure proper updates after a brush modification. Some tile-level changes in `wxwidgets` (like setting flags) might now directly modify `Tile` properties and emit signals.
    - **Focus only on events that cause conceptual visual/data modifications.** How these modifications are rendered or committed to the undo stack is often a subsequent step unless very tightly coupled in `wxwidgets`.
    - **`Task34.md` is critically important: it must dissect the event handling loop, state machines, tile identification algorithms, and action dispatching logic from `wxwidgets::canvas.cpp` and any related brush helper classes, specifying how mouse interaction translated into concrete effects on map data or selection state. Particular attention to drag operations for multi-tile modifications versus single clicks.**
