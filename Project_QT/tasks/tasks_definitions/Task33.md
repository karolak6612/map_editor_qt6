**Task33: Create `BrushManager` in Qt (Full `QObject` System, Creation, Selection Signals, State Update Methods)**
- Task: **Create a robust `BrushManager` class as a `QObject` in `project_qt`. This manager is responsible for the creation, management, and selection of all brush tools used in the editor.**
    - **Analyze Existing `BrushManager`:** Integrate with or refactor any existing brush management logic in `Project_QT/src`.
    - **Brush Creation (`createBrush`):** Implement a factory method, `Brush* BrushManager::createBrush(Brush::Type type, [optional_parameters...])`. This method, using the `Brush::Type` enum (ported from `wxwidgets`), will instantiate and return an instance of the correct concrete `Brush` subclass (e.g., `NormalBrush`, `GroundBrush`, `WallBrush` etc. â€“ these are initially stubs from Task 6, 37-40, 53). The method should handle any initial setup required for each brush type. Consider using smart pointers (`std::shared_ptr` or `std::unique_ptr` if `BrushManager` owns the brushes) for managing brush lifetimes.
    - **Active Brush Management:** `BrushManager` should keep track of the currently active/selected brush.
    - **Qt Signals (replacing wxEvents):**
        -   `void currentBrushChanged(Brush* newBrush, Brush* previousBrush);` (emitted when the active brush changes).
        -   `void brushCreated(Brush* brush);` (emitted when a new brush instance is created, if needed by UI).
        -   `void brushPropertiesChanged(Brush* brush);` (emitted if a brush's internal properties that affect drawing are modified, e.g., by a properties panel).
    - **Brush State Update Methods (as per `Task33.md`):** Implement methods that might be called by other parts of the application (like `MapView` or UI panels) to update the state of the *current* brush or to provide context to brushes. Examples based on original task description:
        -   `void updateFloodFillTargetItems(const QList<Item*>& targetItems);` (if FloodFillBrush needs to know what to replace).
        -   `void updateCurrentBrushTargetType(ItemType targetType);` (if brush behavior depends on target type).
        -   `void setLastSelectedTilesForPaste(const QList<Tile*>& tilesToDrawOn);` (if a paste-like operation using a brush needs target context).
        -   `void updateBrushSize(int newSize);` (if brushes have a size property changed from `MapView`).
    - **Internal Tracking (if original did this):** If `Brush::changed` was an internal signal from individual brush objects in `wxwidgets` (e.g., for item properties updates on an `ItemBrush` that should trigger display reloads, or brush size changes), `BrushManager` might need to connect to such signals from managed brushes (if `Brush` itself becomes a `QObject`).
    - **`Task33.md` must define the complete `Brush::Type` enum, the full list of state update methods `BrushManager` should provide (and how they affect brush operation), and how brush instances are owned/managed.**
