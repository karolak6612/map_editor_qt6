**Task81: Complete Brush Loading/Saving (XML/JSON Persistence for Custom/User-Defined Brushes & States)**
- Task: **Implement comprehensive loading and saving functionality for `Brush` data within `BrushManager` (or a dedicated brush I/O class). This typically involves persisting brush definitions (especially for user-customized brushes, doodad collections, or house template brushes) to XML or JSON files, and loading them back into `BrushManager` on application startup or user request.**
    - **Analyze Existing Brush Persistence:** Review any current brush saving/loading mechanisms in `Project_QT/src`.
    - **Scope of Persistence:** Determine what needs to be saved for brushes (based on original `wxwidgets brushes.cpp/h` load/save logic and `Task81.md`):
        -   Definitions for standard brushes might be hardcoded or loaded from a default factory, but if users could customize properties of standard brushes (e.g., default size, item associated with an `ItemBrush`) and save these customizations, that needs to be handled.
        -   User-created brushes (if the editor supported defining new brushes, e.g., custom doodad assemblies, house templates stored as brushes).
        -   Internal state or properties of specific brush types that are persistent (e.g., a list of items for a "multi-item" brush, filter settings for a specialized eraser).
    - **File Format (XML/JSON):** Use `QXmlStreamWriter/Reader` for XML or `QJsonDocument/Object/Array` for JSON to serialize brush data. `Task81.md` should confirm the target format (if `wxwidgets` had one) or if a new one is preferred.
    - **Serialization Logic:**
        -   For each brush to be saved: write its `Brush::Type`, name, and all relevant configurable properties (e.g., associated `ItemID`, size, specific flags like `Brush::flags` indicating `map->borderize` needs, internal `itemData` type, custom colors).
        -   For brushes that represent collections (like doodad brushes or house brushes referencing complex structures): save the list of constituent `Item` IDs or references to templates.
        -   Raw type brushes (if they are simply placeholders for item types) might just save the item ID they represent.
    - **Deserialization Logic:**
        -   When loading, read the brush type and instantiate the correct `Brush` subclass using `BrushManager::createBrush()`.
        -   Populate the brush's properties from the saved data.
    - **Integration with `BrushManager`:**
        -   `BrushManager` should have `loadBrushes(const QString& filePath)` and `saveBrushes(const QString& filePath)` methods.
        -   These might be called at application startup/shutdown or via "Import/Export Brushes" actions.
    - **Consistency with `Materials` / `BrushPanel`:** Consider how custom loaded brushes are displayed/organized in `BrushPanel` (Task 70) alongside any brushes derived from `ItemTypes` or `Materials` (Tilesets). The original `BrushPanel` sorting or category assignment for loaded brushes should be maintained if applicable.
    - **File Identification:** Implement logic to correctly identify the brush file format if multiple formats are supported or if migrating from an old `wxwidgets` brush file.
    - **`Task81.md` must specify what constituted a "savable" brush in `wxwidgets`, the exact file format used (if any), all properties that were persisted per brush type, and how changes to internal brush states (e.g., after editing in a property panel) were flagged for saving.**
