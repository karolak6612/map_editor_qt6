**Task53: Migrate remaining Brush types to Qt (Carpet, Table, Creature, Spawn, etc. - Full Implementation with Item/Map Interaction)**
- Task: **Implement the remaining `Brush` specializations (beyond Terrain, Wall, Decoration if covered earlier) into individual, fully functional classes in `project_qt`. This includes `CarpetBrush`, `TableBrush`, `CreatureBrush`, `SpawnBrush`, and any others from `wxwidgets brush.cpp/h`, ensuring consistency with the `BrushManager` creation/selection logic and interaction with the new `Tile::items` model.**
    - **Analyze Existing Brush Stubs:** Build upon any stub brush classes created in Task 53's original intent (or earlier brush tasks) in `Project_QT/src`.
    - **For each specific brush type (e.g., `CarpetBrush`, `TableBrush`):**
        -   **Item Placement Logic:** Implement its `draw(Map* map, const QPoint& tilePos, Item* currentItem)` method to correctly place its specific `Item` type(s) onto the `Tile` at `tilePos`. This will involve using `Tile::addItem(Item*)`.
        -   **Item Property Handling:** If the brush sets specific properties on the placed `Item`s (e.g., `TableBrush` might set a variation, `CreatureBrush` sets creature type), ensure this is done.
        -   **Tile State Modification:** If the brush modifies `Tile` flags or state directly (e.g., `DoorBrush` implementing `wall_alignment` logic, or a special brush affecting `Tile::hasHouseExit`), this logic must be ported. If these are now `Item` properties, the brush places an `Item` with those properties.
        -   **Map-Level Recalculation (if original did this):** Port any logic like `doCarpets()`, `recalculateTablesForRect()`, `recalculateWalls()`, `reDoAllCarpets()`. These functions often re-evaluated a rectangular area of tiles after an edit, possibly triggered by the brush. In Qt, these might become methods on `Map` or a dedicated `MapProcessor` class, called after a brush operation completes a batch of changes. These functions should operate on `Tile` data for the specified area/selection.
        -   **Item Management in `Tile`:** Ensure these brushes interact correctly with the new model where `Tile::items` manages properties rather than `Tile` having direct members for every special item (e.g., if `DoorBrush` also implemented `wall_alignment` previously on `Tile`, now it might place a Door `Item` that *has* alignment, or an associated Wall `Item`).
        -   **`hasXXXX` Logic:** Implement any necessary `canDraw()` logic for the brush or ensure `Tile`'s own `hasXXXX()` attribute-based methods (like `Tile::hasGround()`, `Tile::isWall()`) reflect the items placed by these brushes, so that interactions (like placing items on certain ground types only) work correctly. This involves items determining where they can be placed and their render order, potentially through properties read from `ItemType` by the brush during placement checks.
    - **`Item` Attribute Interaction:** Ensure all brush interactions correctly use the new `Item` attribute map (Task 55) for querying or setting specialized item data (e.g., "description" for comments, `weight`, `getElevation`).
    - **Specialized Properties:** For brushes like `DoorBrush` (`setDestination`/Door ID change), or `SpawnBrush` (creature type, radius), these properties should be managed by the brush and applied to the `Item`s or `Spawn` data it creates/modifies. Ensure relevant signals are emitted if these changes require broader map updates (e.g., for minimap or linked property editors).
    - **`Task53.md` (or individual `.md` files per brush type if complex) is crucial. It must describe each brush's unique behavior: what items it placed, how it interacted with tile properties, any specific rules or map recalculations it triggered, and how item attributes determined brush applicability or outcome.**
