**Task100: Refactor, Optimize, Test, and Finalize (Systematic Code Review & Polish, Performance, Comprehensive Testing)**
- Task: **This is the culminating task. Conduct a thorough and systematic review, refactoring, optimization, and testing pass across the *entire* `project_qt` codebase. The goal is to ensure efficient resource handling, a consistent and robust architecture, appropriate and idiomatic usage of Qt's advanced rendering and UI features, resolution of any remaining issues, and a polished, stable application.**
    - **Analyze Codebase State:** Before diving in, assess the overall state of `Project_QT/src`.
    - **1. Refactor for Consistency and Maintainability:**
        -   **Code Style & Conventions:** Ensure consistent coding style, naming conventions, and Qt best practices throughout.
        -   **Architecture Review:** Examine class design, component coupling, and data flow. Refactor areas where architecture became convoluted or inefficient during incremental migration. Ensure appropriate use of Qt's object model (parent/child relationships, signals/slots).
        -   **Reduce Duplication:** Identify and eliminate redundant code.
        -   **Namespace Conflicts:** Resolve any potential namespace conflicts.
        -   **Streamline Data Flow:** If similar property/status checks are called across many places to access data (e.g., `QTile` data via `Items`), streamline access methods. Example from original: using existing `QTile` data now via `Items` to maintain type compatibility for new `Brushes` unless something triggers extra update logic which likely would need similar `tile changed` signals when for instance any of `ItemProperties` flags on `Tile` changes or `HouseId` does now, while also simplifying those methods themselves that don't set properties directly but these should instead use tiles internal data in map after creating/adding an item unless only checking if a certain condition using flags or the actual type present from where tile might generate it based on any existing ones in it (`GroundType`) to avoid multiple steps of placing and adding a specific id and having those functions in addition or calling if already tile had such a `item/property`. (This specific logic needs careful porting if relevant.)
    - **2. Optimize for Performance:**
        -   **Resource Handling:** Ensure efficient loading, caching, and releasing of resources (images, map data, sprites). Fix any memory leaks.
        -   **Rendering Performance:** Profile and optimize rendering in `MapView` and `Minimap`, especially for large maps or complex scenes. Optimize `QGraphicsItem` usage, `paint()` methods, and scene update logic.
        -   **Data Structures & Algorithms:** Review critical data structures and algorithms for performance bottlenecks (e.g., item searching, collision detection, large data iteration).
    - **3. Comprehensive Testing:**
        -   **Functional Testing:** Test *all* migrated features end-to-end, comparing against original `wxwidgets` behavior (aiming for 100% parity where intended). Use a variety of test maps (small, large, complex, edge-case content).
        -   **Key Areas to Test (as per original):** small tiles/test maps at all key areas before building/running the converted larger ones. Test UI responsiveness, all brush types, selection tools & transformations, map I/O for all formats, undo/redo, automagic systems, house/town/waypoint/spawn editing, minimap, all dialogs, preferences.
        -   **Error Handling:** Test robustness against invalid input, corrupted files, unexpected states.
        -   **Resolve Issues:** Fix all remaining functional bugs, visual glitches, warnings (compiler and Qt runtime), and unhandled exceptions.
    - **4. Finalization & Polish:**
        -   **Qt Object System Updates:** If initial global instances were managed via `MainWindow` members and their signals, update to a more robust Qt object system if appropriate (e.g., singleton patterns for managers if necessary, ensuring proper object ownership and destruction).
        -   **Thread Safety (Memory Management):** If multi-threading was used (e.g., Task 88, Task 32), ensure thread-safe memory management and use Qt-equivalent data structures or synchronization primitives (`QMutex`, `QReadWriteLock`, implicitly shared classes) correctly. This applies especially if data (like from `QList`, `std::vector/list/queue/deque`, smart pointers like `std::unique_ptr`) was temporarily stored and passed between threads or if `MainWindow` managed deletion logic on unload that might now be instance-managed.
        -   Address all TODOs in the code.
        -   Complete any missing inline documentation or user-facing tooltips.
    - **`Task100.md` must provide a checklist of specific areas known to require refactoring, optimization targets, critical test cases, and any final architectural patterns to enforce (e.g., use of Qt's global instances vs. `MainWindow` members, specific data structure choices for Qt compatibility for memory shared across threads). This description needs to be extremely thorough due to its broad scope.**
